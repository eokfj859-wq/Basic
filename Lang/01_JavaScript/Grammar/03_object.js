// 1. 기본형 데이터
var a = 10;
var b = a; // 변수 b에 a의 '값(10)'을 복사해서 새로운 메모리에 담음

b = 20; 

console.log(a); // 10 (b를 바꿨지만 a는 전혀 영향 없음)
console.log(b); // 20
// [메모리 시뮬레이션]
// 주소 101: [ 10 ]  <- a가 가리킴
// 주소 102: [ 20 ]  <- b가 가리킴 (기존 10을 바꾼 게 아니라 새 공간 확보)


// 2. 참조형(array도 포함) 데이터 - 객체(object)
var obj1 = {
    a: 0,
    b: 'abc'
};

var obj2 = obj1; // 변수 obj2에 obj1의 '주소값'을 복사함 (포인터 복사와 같음)

// [메모리 시뮬레이션]
// 주소 501: [ @701 ] <- obj1, obj2 둘 다 이 주소를 가짐 (C의 포인터)
// 주소 701: { a: 0, b: 'abc' } (실제 객체 데이터가 담긴 힙 영역)

obj2.a = 2; // obj2를 통해 내부 값을 변경

console.log(obj1.a); // 2 (obj2만 바꿨는데 obj1도 바뀌어 있음)
console.log(obj2.a); // 2
console.log(obj1 === obj2); // true (둘이 가리키는 주소가 완벽히 같음)


// 3. 만약 객체를 '불변'처럼 새로 할당한다면?
obj2 = { a: 2, b: 'def' }; 
// 이렇게 하면 기존 주소의 값을 바꾸는 게 아니라, 아예 새로운 객체를 만들어 주소를 갈아끼움

console.log(obj1 === obj2); // false (이제 서로 다른 주소를 바라봄)